# 第二章 多线程编程的目标与挑战

本章通过一些基本概念，讲解多线程编程的目标及面临的挑战。这些概念是学习后续章节的基础，也是设计多线程程序和实际工作中分析和定位多线程问题的基础。

## 串行、并发和并行

假设我们有3个任务A、B、C。其用时为（O表示运行，X表示等待）：
A: XXXXOOXXOOX  用时11
B: XXOOXXOOX    用时9
C: XXXOOXX      用时7

如果用串行的方式工作:
A: XXXXOOXXOOX
B:            XXOOXXOOX
C:                     XXXOOXX
共耗时27。

如果用并发的方式工作，并发的原则是 1）如果一个进入等待，可以转而执行其他任务；2）一个任务最多连续执行3个时间片
A: XXX     XOO  XXOOX
B:    XXOO  XXOO  X
C:      XXXOO XX
共耗时18。

如果3个任务并行工作：
A: XXXXOOXXOOX
B: XXOOXXOOX
C: XXXOOXX
共耗时11。

从软件的角度，并发就是在一段时间内已交替的方式去完成多个任务。并行就是以齐头并进的方式去完成多个任务。软件要以并发的方式去完成几个任务，需要借助多个线程(而不是一个线程)。

从硬件的角度，一个处理器就可以实现并发。而并行则需要依靠多个处理器在同一时刻各自运行一个线程来实现。

多线程编程的实质就是将任务的处理方式由串行改为并发，实现并发化。如果一个任务的处理方式可以由串行改为并发，则称该任务是可并发化的。

## 竞态

多线程编程中经常遇到，对于同样的输入，程序的输出有时正确，有时错误。这种计算结果的正确性与时间有关的现象被称为竞态(Race Condition)。

### 二维表分析法：解释竞态的结果

状态变量(State Variable): 类的实例变量、静态变量；
共享变量(Shared Variable): 可以被多个线程共同访问的变量。共享变量中的“共享”强调的是“可以被共享”的可能性。状态变量由于可以被多个线程共享，因此也被称为共享变量。

导致竞态的常见因素是：多个线程在没有采取任何控制措施的情况下，并发地更新、读取同一个共享变量。

竞态(Race Condition)可以被进一步定义为：计算结果的正确性依赖于相对时间顺序或线程的交错。

竞态往往伴随着读取脏数据(Dirty Read)问题，即线程读取到一个过时的数据；丢失更新(Lost Update)问题，即一个线程对数据所做的更新没有体现在后续其他线程对该数据的读取上。

### 竞态的模式和竞态产生的条件

静态典型实例可以提炼出两种模式：read-modify-write(读-改-写)和 check-then-act(检测后行动)。

read-modify-write 操作可以被细分为以下步骤：

1. 读取一个共享变量的值(read);
2. 根据该值做一些计算(modify);
3. 更新该共享变量的值(write);

check-then-act 操作可以被细分为以下步骤：

1. 读取某个共享变量的值；
2. 根据该变量值决定的执行动作；

竞态条件产生的一般条件：设 O1 和 O2 是并发访问共享变量V的两个操作，这两个操作并非都是读操作。如果一个线程在执行 O1 期间（开始执行而未执行结束），另一个线程正在执行 O2，那么无论 O2 是在读取还是在更新V都会导致竞态。从这个角度看，竞态可以被看作访问同一组共享变量的多个线程所执行的操作相互交错。

synchronized 关键字会使其修饰的方法在任一时刻只能有一个线程访问，从而避免了这个方法的交错执行而导致的干扰，这是一种消除竞态的方式。

## 线程安全性

一般而言，如果一个类在单线程环境下能够运行正常，并且在多线程环境下，再起使用方不必为其做任何改变的情况下也能运行正常，那么我们称其为线程安全(Thread-safe)的，相应地，我们称这个类具有线程安全性(Thread Safety)。反之，如果一个类在单线程环境运行正常，多线程环境不正常，则该类是非线程安全的。

一个类如果能够导致竞态，就是非线程安全的。如果是线程安全的，则不会导致竞态。

使用一个类的时候，我们必须先清除该类是否线程安全。Java 标准中的一些类，如 ArrayList、HashMap 和 SimpleDateFormat 都是非线程安全的，在多线程环境下直接使用它们可能导致一些非预期结果，甚至是一些灾难性的结果。

从线程安全的定义上可以看出，如果一个线程安全的类在多线程环境中能够正常运行，则它在单线程环境下也能正常运行。是否将一个类做成线程安全的，从某种程度上来说是一个设计上权衡的结果。一方面，一个类是否需要线程安全与该类预期被使用的方式有关，例如，我们希望一个类总是只能被一个线程独自使用，那么久没必要将这个类做成线程安全的。其次，把一个类做成线程安全的往往有额外的代价。

一个类如果不是线程安全的，我们就说它在多线程环境下直接使用存在线程安全问题。线程安全问题概括来说表现为3个方面：原子性、可见性和有序性。

## 原子性

对于涉及共享变量访问的操作，若该操作从其执行线程以外的任何线程来看都是不可分割的，那么该操作就是原子操作。相应地，我们称该操作具有原子性(Atomicity)。

所谓的不可分割，其中一个含义是指访问(读、写)的某个共享变量的操作，从其执行线程以外的任何线程来看，该操作要么已经执行结束，要么尚未发生，即其他线程不会“看到”该操作执行了部分的中间效果。

设 O1 和 O2 是访问共享变量 V 的两个原子操作，这两个操作并非都是读操作。你们，一个线程执行 O1 期间(开始执行而未执行完毕)，其他线程无法执行 O2。也就是说，访问同一组共享变量的原子操作不能被交错。

总结，操作的原子性包含两层含义：

1. 执行线程外的任何线程，操作要么已经完成，要么还未发生，不存在中间状态；
2. 访问同一组共享变量的原子操作不能被交错；

总的来说，Java 有两种方式保证原子性：1、锁，它能保证一个共享变量在任意时刻只被一个线程访问；2、CAS（Compare-ans-Swap）指令，CAS 指令实现原子性的方式与锁实现原子性的方式实质上是相同的，差别在于锁通常是在软件层面实现，而CAS是直接在硬件层面实现；

在 Java 中，long 类型和 double 类型以外的任何基础类型的写操作都是原子操作。对于 volatile 关键字修饰的 long/double 型变量的写操作具有原子性。

## 可见性

在多线程环境下，一个线程对某个共享变量进行更新后，后续访问该变量的线程可能无法立刻读到这个更新的结果，甚至永远也无法读到这个更新的结果，这就是线程安全问题的另一个表现形式，可见性(Visibility)。

如果一个线程对某个共享变量进行更新后，后续访问该变量的线程可以读取到该更新的结果，那么我们称这个线程对该共享变量的更新对其他线程可见。多线程程序在可见性方面存在问题意味着某些线程读取到旧数据(Stale Date)，而这可能导致程序出现我们所不期望的结果。例如：
```java
public class NoVisibility {
    private static boolean ready; 
    private static int number;
    
    private static class ReaderThread extends Thread {
        public void run() {
            while(!ready) {
                Thread.yield();
            }
            System.out.println(number);
        }
    }
    
    public static void main(String[] args) {
        new ReaderThread().start(); //启动一个线程
        number = 42;
        ready = true;
    }
}
```
上述代码的执行可能不能退出（java8 没出现该效果）。因为主线程对 ready 的修改并没有被子线程发现。

另一方面，可见性问题与计算机的存储系统有关。程序中的变量可能会被分配到寄存器（Register）而不是主内存中进行存储。每个处理器都有其寄存器，而一个处理器不能读取另一个处理器寄存器的值。如果两个线程分别在不同的处理器上，而这两个线程所共享的变量却被分配到寄存器上进行存储，那么可见性问题就会产生。

另外，即便某个变量是被分配到主存中进行存储，也不能保证该变量的可见性，这是因为处理器对主存的访问不是直接访问，而是通过高速缓存(Cache)子系统进行的。

虽然一个处理器的高速缓存中的内容不能被另一个处理器直接读取，但是一个处理器可以通过缓存一致性协议(Cache Coherence Protocol)来读取其他处理器的高速缓存中的数据，并将读到的数据更新到该处理器的高速缓存中。这种一个处理器从其自身处理器缓存以外的其他存储部件中读取数据并将其反映(更新)到该处理器对的高速缓存的过程称为缓存同步。

缓存同步使一个处理器可以读取到另一个处理器对共享变量的更新，即保障了可见性。

为了保证可见性，我们必须使一个处理器对共享变量的更新最终被写入到该处理器的高速缓存或主内存中(而不是停留在写缓冲器中)，这个过程称为**冲刷处理器缓存**。并且，一个处理器在读取共享变量的时候，如果其他处理器在此之前已经更新了该变量，那么该处理器必须从其他处理器的高速缓存或主存中对相应变量进行缓存同步，这个过程称为**刷新处理器缓存**。

因此，可见性的保证是通过使更新共享变量的处理器冲刷处理器缓存的动作，并使读取共享变量的处理器执行刷新处理器缓存的动作来实现的。

volatile 关键字所起的一个作用是，提示 JIT 编译器被修饰的变量可能被多个线程所共享，以阻止JIT编译器做出可能导致程序运行不正常的优化。另一个作用是读取一个 volatile 关键字修饰的变量会使相应的处理器执行冲刷处理器缓存的动作，从而保证可见性。

另外，由于某些处理器(如常见的x86处理器)在可见性方面足够强大，加上实际工作中我们能够接触到的处理器类型有限，因此可见性问题不是必然出现的。当不意味着我们可以心存侥幸地忽视它。

约定：对于同一个共享变量而言，一个线程更新了该变量的值之后，其他线程能够读取到这个更新后的值，那么这个值就被称为该变量的相对新值。如果读取这个共享变量的线程在读取并使用该变量的时候其他线程无法更新该变量，那么该线程读到的相对新值就被称为该变量的最新值。

可见性保证一个线程可以读到共享变量的相对新值，不能保证该线程能够读取到相应变量的最新值。

Java 语言规范(JLS, Java Language Specification)保证：
- 父线程在启动子线程之前对共享变量的更新对子线程是可见的；
- 一个线程终止后，该线程对共享变量的更新对于调用该线程的join方法的线程而言是可见的。

## 有序性

### 重排序

顺序结构是结构化编程中的一种基本结构，它表示我们希望某个操作先于另一个操作得以执行。另外，两个操作即便可以用任意一种顺序执行，但反映在代码上这两个操作也是有先后顺序的。但在多核处理器环境下，这种操作执行顺序可能没有保障：编译器可能改变两个操作的先后顺序，处理器可能不是完全按照程序的目标代码所指定的顺序执行指令。这种现象称为重排序。

重排序是对内存访问有关的操作(读和写)所做的一种优化，它可以在不影响多线程程序正确性的情况下提升程序的性能。但也可能导致线程安全问题。

重排序的潜在来源有很多，如编译器(JIT编译器)、处理器和存储子系统。

术语定义：
- 源代码顺序(Source Code): 源代码中指定的内存访问操作顺序。
- 程序顺序(Program Code): 在给定处理器上的目标代码(Object Code)所指定的内存访问操作顺序，在java中为字节码。
- 执行顺序(Execution Order): 内存访问操作在给定处理器上的实际执行顺序。
- 感知顺序(Perceived Order): 给定处理器所感知到的该处理器及其他处理器的内存访问操作发生的顺序。

我们将重排序分为指令重排序和存储子系统重排序两种：

|重排序类型|重排序表现|重排序来源(主题)|
|---------|--------|--------------|
|指令重排序 |程序顺序与源代码顺序不一致|编译器|
|(同上)|执行顺序与程序顺序不一致|JIT编译器、处理器|
|存储子系统重排序|源代码、程序顺序和执行顺序一致，但是感知顺序与执行顺序不一致|高速缓存、写缓冲器|

### 指令重排序

Java 平台包含两种编译器：静态编译器(javac)和动态编译器(JIT编译器)。Javac 是将 Java 源代码(.java文本文件)编译成字节码(.class二进制文件)，它是在代码编译阶段介入的。后者是将字节码编译为 Java 虚拟机宿主机的本地代码(机器码)，它是在 Java 程序运行过程中介入的。

在其他编译型语言(如C++)中，编译器是可能导致指令重排序的：编译器出于性能考虑，在其认为不影响程序(单线程程序)正确性的情况下可能会对源代码顺序进行调整，从而造成程序顺序与相应的源代码顺序不一致。在 Java 平台中，静态编译器(javac)基本上不会执行指令重排序，而 JIT 可能执行指令重排序。

### 存储子系统重排序

主内存是慢速设备，处理器并不是直接访问主存，而是通过高速缓存(Cache)访问，现代处理器还引入了写缓冲器(Store Buffer,也称 Write Buffer)以提高写高速缓存操作。我们将写缓冲器和高速缓存统称为存储子系统，它其实是处理器的子系统。

即使是在处理器严格按照程序顺序执行两个内存访问操作的情况下，在存储子系统的作用下，其他处理器对这两个操作的感知顺序仍然可能与程序顺序不一致，即两个操作的执行顺序看起来是发生了变化。这种现象称为存储子系统重排序，也称为内存重排序(Memory Ordering)。

从处理器的角度来说，读内存操作的实质是从指定 RAM 加载数据到寄存器，因此读内存操作通常被称为 Load，写内存操作的实质是将数据存储到指定的 RAM 中，因此写内存操作常被称为 Store。

内存重排序只有 4 中：

|重排序类型|含义|
|---|---|
|LoadLoad 重排序|处理器先后执行两个 Load 操作 L1、L2，在其他处理器看来执行顺序为L2、L1|
|StoreStore 重排序|处理器先后执行两个 Store 操作 S1、S2，在其他处理器看来执行顺序为S2、S1|
|LoadStore 重排序|处理器顺序执行 L1、S2，其他线程看起来为 S2、L1|
|StoreLoad 重排序|处理器顺序执行 S1、L2，其他线程看起来为 L2、S1|

### 貌似串行语义

重排序并非随意地对指令、内存操作的结果进行杂乱无章的排序或顺序调整，而是遵循一定的规则。编译器、处理器都会遵守这些规则，从而给多线程程序创造一种假象(Illusion)--指令是按源码顺序执行的。这种假象称为貌似串行语句。

### 保证内存访问的顺序性

从底层角度来说，禁止重排序是通过调用处理器提供相应的指令(内存屏障)来实现的。Java 作为一个跨平台的语言，它会替我们与这些指令打交道，而我们只需要使用语言本身的机制即可。前面介绍的 synchronized 和 volatile 都能够实现有序性。

可见性是有序性的基础。可见性描述的是一个线程对共享变量的变更对于另一个线程是否看见，或者说什么情况下可见的问题。有序性描述的是，一个处理器上运行的线程对共享变量的更新，在其他处理器上运行的其他线程来看，这些线程是以什么样的顺序观察到这些更新的问题。

## 上下文切换

上下文切换(Context Switch)在某种程度上可以被看作多个线程共享同一个处理器的产物，它是多线程编程中的一个重要概念。

### 上下文切换及其产生原因

当一个进程中的一个线程由于其时间片用完或者其自身的原因(比如需要等待)，被迫或主动暂停运行时，另一个线程可以被操作系统(线程调度器)选中占用处理器开始或者继续其运行。这种一个线程被暂停，即被剥夺处理器的使用权，另外一个线程被选中开始或继续运行的过程称为线程上下文切换。

相应地，一个线程被剥夺处理器的使用权而被暂停运行被称为切出(Switch Out),一个线程被操作系统选中占用处理器开始或继续其运行就被称为切入(Switch In)。

上下文(Context)一般包括通用寄存器的内容和程序计数器的内容。在切出时，操作系统需要将上下文保存在内存中，以便被切出的线程稍后占用处理器继续其运行时能够在此基础上进行。

### 上下文切换的分类及具体诱因

按照导致上下文切换的因素划分，我们可以将上下文切换分为自发性上下文切换(Voluntary Context Switch)和非自发性上下文切换(Involuntary Context Switch)。自发性上下文切换指线程由于其自身因素导致的切出。例如执行下列的任意操作：
- Thread.sleep(long millis)
- Object.wait() / wait(long timeout) / wait(long timeout, int nanos)
- Thread.yield()
- Thread.join() / Thread.join(long timeout)
- LockSupport.park()

另外，线程发起 I/O 操作或等待其他线程持有的锁，也会导致自发性上下文切换。

非自发性上下文切换指线程由于线程调度器的原因被迫切出。导致非自发性上下文切换的常见元素包括被切出线程的时间片用完或有一个比被切出线程优先级更高的线程需要运行。

从 Java 平台的角度来看，Java 虚拟机的垃圾回收(Garbage Collect)动作也可能导致非自发性上下文切换。这是因为垃圾回收器在执行垃圾回收的过程中可能需要暂停所有应用线程(Stop-the-world)才能完成其工作。比如在主要回收(Major Collection)过程中，垃圾回收器在对 Java 虚拟机堆内存区域进行整理(Compact)的时候需要先停止所有应用线程。

### 上下文切换的开销和测量

一方面，上下文切换是必要的，即使是在多核处理器中上下文切换也是必要的，因为一个系统上需要运行线程的数量相对于该系统所拥有的处理器数量总是要多得多。另一方面，上下文切换的开销不小。

从定性角度来说，上下文切换的开销包括直接开销和间接开销。其中，直接开销包括：
- 操作系统保存和恢复上下文所需开销，这主要是处理器时间开销；
- 程序调度器镜像线程调度的开销；

间接开销包括：
- 处理器高速缓存重新加载的开销；
- 上下文切换也可能导致整个一级高速缓存中的内容被冲刷(Flush)，即一级高速缓存中的内容被写入下一级高速缓存或主存(RAM)。

从定量的角度来说，一次上下文切换的时间消耗是微秒级的。

多线程编程相比于单线程而言，意味着更多的上下文切换，因此多线程编程的计算效率不一定比单线程编程的计算效率更高。

## 线程的活性故障

线程是为任务而生的，因此，理想情况下我们希望线程一直处于 RUNNABLE 状态。导致一个线程可能处于非 RUNNABLE 状态的元素除了资源限制之外，还有程序自身的问题和缺陷，称为线程活性故障(Livenness Failure)。

常见的活性故障包括：
- 死锁(Deadlock)
- 锁死(Lockout): 锁死好比睡美人故事中，睡美人醒来的前提是她要得到王子的吻，但王子挂了，那么睡美人将一直沉睡。
- 活锁(Livelock)： 活锁好比小猫试图咬住自己的尾巴，虽然它一直追着自己的尾巴咬，但始终无法咬到。表现为虽然处于 RUNNABLE 状态，但所要执行的任务没有丝毫进展，即线程可能一直在做无用功。
- 饥饿(Starvation): 线程因无法获得其所需的资源而使得任务无法进展的现象；

## 资源争用与调度

由于资源的稀缺性或资源本身的特性，我们往往需要在多个线程间共享同一个资源。一次只能被一个线程占用的资源称为排他性(Exclusive)资源。常见的排他性资源包括处理器、数据库链接、文件等。

在一个线程占用一个排他性资源进行访问而未释放其对资源所有权时，其他线程试图访问该资源的现象称为资源争用(Resource Contention)，简称争用。

非公平调度策略是我们多数情况下的首选资源调度策略。优点是吞吐率大，缺点是资源申请者申请资源所需的时间偏差较大，可能导致饥饿现象。公平调度策略适合在资源的持有线程占用资源的时间相对较长或资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用。优点是线程申请资源所需的时间偏差较小，不会导致饥饿现象，缺点是吞吐率小。


