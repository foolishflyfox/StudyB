# 单元测试

计算机世界中的软件产品通常是由模块组合而成的，模块又可以分为诸多子模块。比如淘宝系统由搜索模块、商品模块、交易模块等组成，而交易模块又分为下单模块、支付模块、发货模块等子模块，如此细分下去，最终的子模块是由不可再分的程序单元组成。对于这些程序单元的测试称为单元测试(Unit Testing，简称单测)。

单元的粒度要根据实际情况判定，可能是类、方法等，在面向对象编程中，通常认为最小单元是方法。单元测试的目的是在集成测试和功能测试前对软件中可测试单元进行逐一检查和验证。单元测试是程序功能的基本保障，是软件产品上线前非常重要的一环。

单元测试的好处：

1. 提升软件质量：优质的单元测试可以保障开发质量和程序的鲁棒性。开发工程师在研发过程中都会频繁执行测试用例，运行失败的单测能帮助我们快速排查和定位问题，使问题在被带到线上前完成修复。软件工程界的一条金科玉律，越早发现的缺陷，其修复成本越低。
2. 促进代码优化：单元测试是由开发工程师编写和维护的，这会促使开发工程师不断重新审视自己的代码，白盒地去思考代码逻辑，更好地对代码进行设计，设置想方设法地优化测试用例的执行效率。这个过程会促使我们不断优化自己的代码。
3. 编写单测表面上占用了项目研发时间，但磨刀不误砍柴工，在后续的联调、集成、回归测试阶段，单元测试覆盖率越高的代码，缺陷通常越少、问题越容易修复，有助于提升项目的整体研发效率。
4. 增加重构自信

## 单元测试的基本原则

宏观上，单元测试要符合 AIR 原则；微观上，单元测试的代码层面要符合BCDE原则。

AIR 原则包括：A automatic(自动化)、I Independent(独立性)、R Repeatable(可重复)。

单元测试应该是全自动执行的。测试用例通常会被频繁地触发执行，执行过程必须完全自动化才有意义。如果单元测试的输出结果需要人工介入检查，那它一定是不合格的。单元测试不允许使用 System.out 来进行人工验证，必须使用断言来验证。

为了保证单元测试稳定可靠且便于维护，需要保证其独立性。用例之间不允许相互调用，也不允许出现执行次序的先后依赖。例如下面的代码:
```java
@Test
public void testMethod1() {
    ... ...
}
@Test
public void testMethod2() {
    testMethod1();
    ... ...
}
```
testMethod2 需要调用 testMethod1。在执行 testMethod2 时会重复执行验证 testMethod1，导致运行效率降低。更严重的是，testMethod1 的验证失败会影响 testMethod2 的执行。

在主流测试框架中，JUnit 的用例执行顺序是无序的，而 TestNG 支持测试用例的顺序执行(默认测试类内部各个测试用例是按字典序升序执行的，也可以通过 XML 或注解 priority 的方式来配置执行顺序)。

单元测试是可以重复执行的，不受外界环境的影响。比如，测试环境通常会被放到持续集成中，每次有代码提交时，单元测试都会被触发执行。如果单测对外部环境(网络、服务、中间件等)有依赖，很容易导致程序集成机制的不可用。

编写单元测试时，要保证测试粒度足够小，这样有助于精确定位问题。单元测试用例默认是方法级别的。单测不否则跨类或跨系统的交互逻辑，那是集成测试要覆盖的范围。

编写单元测试用例时，为了保证被测模块的交付质量，需要符合 BCDE 原则：

- B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等；
- C：Correct，正确的输入，并得到预期的结果；
- D：Design，与设计文档相结合，来编写单元测试；
- E：Error，单元测试的目的是证明程序有错，而不是程序无错。为了发现代码中潜在的错误，我们需要编写测试用例时，有一些强制额输入错误(如非法数据、异常流程、非业务允许输入等)来得到预期的错误结果。

由于单元测试只是系统集成测试前的小规模测试，有些元素往往是不具备的，因此需要进行 Mock，例如：
1. 功能因素：比如，被测试方法内部调用的功能不可用；
2. 时间因素：比如双十一还没到来，与此时间相关的功能点；
3. 环境因素：政策环境，多端环境；
4. 数据因素：线下数据样本过小，难以覆盖各种线上真实场景；
5. 其他元素。

最简单的 Mock 方式是硬编码，更为优雅的方式是使用配置文件，最佳方式是使用相应的 mock 框架，例如 JMockit、EasyMock、JMock 等。Mock 的本质是让我们写出更加稳定的单元测试，隔离上述元素对单元测试的影响，使结果变得可预测，做到真正的“单元”测试。

## 单元测试覆盖率

单元测试是一种白盒测试，测试者依据程序的内部结构来实现测试代码。单测覆盖率是指业务代码被单测测试的比例和程度，它是衡量单元测试好坏的一个重要指标。各类覆盖率指标从粗到细、从弱到强排列如下。

### 1、粗粒度的覆盖

粗粒度的覆盖包括类覆盖和方法覆盖两种。类覆盖是指类中只要方法或变量被测试用例调用或执行到，那么就说这个类被测试覆盖了。方法覆盖同理，只要在测试用例执行过程中，某个方法被调用了，则无论执行了该方法中的多少行代码，都可以认为该方法被覆盖了。从实际测试场景来看，无论是以类覆盖率还是方法覆盖率来衡量测试覆盖范围，其粒度都太粗了。

### 2、细粒度的覆盖

细粒度的覆盖包括以下几种。

#### a. 行覆盖(Line Coverage)

行覆盖也称为语句覆盖，用来度量可执行的语句是否被执行到。行覆盖率的计算公式的分子是执行到的语句行数，分母是总的可执行语句行数。示例代码如下：
```java
public class CoverageSampleMethods {
    public Boolean testMethod(int a, int b, int c) {
        boolean result = false;
        if (a == 1 && b == 2 || c == 3) {
            result = true;
        }
        return result;
    }
}
```
以上方法中有 5 行可执行语句和3个入参，针对此方法编写测试用例如下：
```java
@Test
@DisplayName("line coverage sample test")
void testLineCoverageSample() {
    CoverageSampleMethods coverageSampleMethods = new CoverageSampleMethods();
    Assertions.assertTrue(coverageSampleMethods.testMethod(1,2,0));
}
```
以上测试用例的行覆盖率为 100%，但是 c==3 的条件判断根本没有被执行到，由此可见，行覆盖率的覆盖强度并不高，但由于容易计算，因此在主流的覆盖率计算工具中，它依然是十分常见的参考指标。

#### b. 分支覆盖(Branch Coverage)

分支覆盖也称为判定覆盖，用来度量程序中每一个判定分支都执行到。分支覆盖率的计算公式中的分子是代码中被执行到的分支数，分母是代码中所有分支的总数。例如前面的例子中，`(a==1 && b==2 || c==3)` 整个条件为一个判定，测试数据至少保证此判定为真和为假的情况都被覆盖到。分支覆盖容易与下面要说的条件判定覆盖，因此我们先介绍条件判定覆盖定义，然后，再比对两者的区别。
#### c. 条件判断覆盖(Condition Decision Coverage)

条件判定覆盖要求设计足够的测试用例，能够让判定中每个条件的所有可能情况至少被执行一次，同时，每个判定本身的所有可能结果也至少执行一次。例如 `(a==1 && b==2 || c==3)`这个判定中包含了3种条件，即 a==1、b==2 和 c==3。为了便于理解，我们仍使用行覆盖率中的 testMethod 方法作为被测方法，测试用例如下：
```java
@ParameterizedTest
@DisplayName("Condition Decision coverage sample test result true")
@CsvSource({
    "0, 2, 3",
    "1, 0, 3"
})
void testConditionDecisionCoverageTrue(int a, int b, int c) {
    CoverageSampleMethod coverageSampleMethods = new CoverageSampleMethods();
    Assertions.assertTrue(coverageSampleMethods.testMethod(a, b, c));
}
@DisplayName("Condition Decision coverage sample test result false")
void testConditionDecisionCoverageFalse() {
    Assertions.assertFalse(coverageSampleMethods.testMethod(0, 0, 0));
}
```
通过 `@ParameterizedTest` 我们可以定义一个参数化测试。`@CsvSource` 注解使得我们可以通过定义一个 String 的数组来定义多次运行测试时的参数列表，而每一个 String 值通过逗号分隔后的结果，就是每一次测试运行时的实际参数值。

分支覆盖只要求覆盖分支所有可能的结果，可以看出它是条件判定覆盖的一个子集。

#### d. 条件组合覆盖(Multiple Condition Coverage)

对于一个包含了 n 个条件的判定，至少需要 $2^n$ 个测试用例才可以。虽然这种覆盖足够严谨，但无疑给编写测试用例增加了指数级的工作量。

#### e. 路径覆盖(Path Coverage)

路径覆盖要求能够测试到程序中所有可能的路径。以 `a==1 && b==2 || c==3` 的所有路径为 ：`a==1,b==2` / `a==1,b!=2,c==3` / `a==1,b!=2,c!=3` / `a!=1,c==3` / `a!=1,c!=3` 。

## 单元测试编写

单元测试编写是开发工程师的日常工作之一，利用好各种测试框架并掌握好单元测试编写技巧，往往可以达到事半功倍的效果。本文主要介绍如何编写 JUnit 测试用例。我们先简要了解一下 JUnit 单元测试框架。

### JUnit 单元测试框架

Java 语言的单元测试框架相对统一，JUnit 和 TestNG 几乎始终处于市场的前两位。其中 JUnit 以较长的发展历史和源源不断的功能演进，得到大多数用户的青睐。JUnit5 对 JDK8 及以上的版本有了更好的支持，并加入了更多的测试形式，如重复测试、参数化测试等。

JUnit5.x 由以下3个主要模块组成。

- JUnit Platform：用于在 JVM 上启动测试框架，统一命令行、Gradle 和 Maven 等方式执行测试的入口。
- JUnit Jupiter：包含 JUnit5.x 全新的编程模型和扩展机制。
- JUnit Vintage：用于在新的框架中兼容运行 JUnit3.x 和 JUnit4.x 的测试用例。

为了便于开发者将注意力放在测试编写上，即不必关心测试的执行流程和结果展示，JUnit 提供了一些辅助测试的注解。常见的测试注解如下：
- `@Test`: 注明一个方法是测试方法，JUnit 框架会在测试阶段自动找出所有使用该注解标明的测试方法并运行。需要注意的是，在 JUnit5 版本中，取消了该注解的 timeout 参数的支持；
- `@TestFactory`(5): 注明一个方法是基于数据驱动的动态测试数据源；
- `@ParameterizedTest`
- `@RepeatTest`
- `@BeforeEach`
- `@AfterEach`
- `@BeforeAll`
- `@AfterAll`
- `@Disabled`
- `@Nested`
- `@Tag`

